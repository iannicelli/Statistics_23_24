<!-- Javascript progressive tutorial by example for students, by Tom Gastaldi, University of Rome "Sapienza",
tommaso.gastaldi@gmail.com, WhatsApp: 3272347610. Please report corrections, improvements, reference links, etc.-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <script src="Rettangolo.js?Ver20"></script>
  <script src="My2dUtilities.js?Ver20"></script>
  <script src="MyChartUtilities.js?Ver20"></script>
  <script src="MyRndUtilities.js?Ver20"></script>
  <script src="MyDistributionUtilities.js?Ver20"></script>

  <title>Euler-Maruyama stochastic differential equation (SDE) simulator</title>
  <style>

    body * {
      font-family: verdana, sans-serif;
      font-size: 13px;
    }

    h3 {
      font-weight: bold;
      font-family: verdana, sans-serif;
      color: maroon;
    }

    label {
      font-weight: bold;
      grid-column: label;
      alignment: top;
      color: rgb(130, 23, 41);
      display: inline-block;
    }

    input[type="radio"] {
      width: 60px;
      grid-column: input;
    }

    input[type="number"] {
      margin-right: 20px;
    }

    div {
      height: 600px;
      background-color: whitesmoke;
      display: grid;
      grid-template-columns: [input] 50px [label];
      align-content: start;
      grid-row-gap: 15px;
    }

    canvas {
      background-color: black;
      border: 1px solid rgb(130, 23, 41);
      vertical-align: top;
      margin-left: 10px;
      float: left;
    }

  </style>

</head>
<body>

<h3>Euler-Maruyama simulator for stochastic differential equation (SDE)</h3>

<button id="buttonRecompute" type="button" style="margin-left: 10px; margin-right: 20px">Generate new</button>

<label for="inputTimes"># times:</label>
<input type="number" id="inputTimes" value=1000 min="10" max="10000" step="10">
<label for="inputPaths"># sample paths:</label>
<input type="number" id="inputPaths" value=500 min="10" max="10000" step="10">

<label for="inputMu">μ (drift):</label>
<input type="number" id="inputMu" value=0 min="-20" max="20" step=".1">
<label for="inputSigma">σ (diffusion):</label>
<input type="number" id="inputSigma" value=1 min="0.1" max="1000" step=".1">
<label for="inputLambda">λ:</label>
<input type="number" id="inputLambda" value=50 min="1" max="1000" step="1">
<label for="inputLambda">&#952;:</label>
<input type="number" id="inputTheta" value=2.0 min="0.2" max="20" step="0.1">


<hr>
<canvas id="myCanvas" width="900" height="600" oncontextmenu="return false;"></canvas>

<div style="horiz-align: right ">

  <input type="radio" id="check_BROWNIAN_MOTION_STANDARD" name="gruppo" checked>
  <label for="check_BROWNIAN_MOTION_STANDARD">Brownian Motion (Wiener standard) [µ=0, σ=1]</label>

  <input type="radio" id="check_BROWNIAN_MOTION_GEN" name="gruppo">
  <label for="check_BROWNIAN_MOTION_GEN">Brownian Motion (general, arithmetic) [uses µ, σ]</label>

  <input type="radio" id="check_BROWNIAN_MOTION_GEO" name="gruppo">
  <label for="check_BROWNIAN_MOTION_GEO"> Brownian Motion (geometric) [uses µ, σ]</label>

  <input type="radio" id="check_ORNSTEIN_UHLENBECK" name="gruppo">
  <label for="check_ORNSTEIN_UHLENBECK"> Ornstein-Uhlenbeck [uses &#952;, µ, σ]</label>


</div>

<script>

    "use strict";

    //enum per scegliere il tipo di grandezza da rappresentare
    const MyChosenVariate = Object.freeze({
        BROWNIAN_MOTION_STANDARD: Symbol("brownianMotion_Standard"),
        BROWNIAN_MOTION_GENERAL: Symbol("brownianMotion"),
        BROWNIAN_MOTION_GEO: Symbol("brownianMotion_Geometric"),
        ORNSTEIN_UHLENBECK: Symbol("ornsteinUhlenbeck")
    });

    const buttonRecompute = document.getElementById("buttonRecompute");
    const inputMu = document.getElementById("inputMu");
    const inputSigma = document.getElementById("inputSigma");
    const inputLambda = document.getElementById("inputLambda");
    const inputTimes = document.getElementById("inputTimes");
    const inputPaths = document.getElementById("inputPaths");
    const inputTheta = document.getElementById("inputTheta");

 


    const check_BROWNIAN_MOTION_STANDARD = document.getElementById("check_BROWNIAN_MOTION_STANDARD");
    const check_BROWNIAN_MOTION_GEN = document.getElementById("check_BROWNIAN_MOTION_GEN");
    const check_BROWNIAN_MOTION_GEO = document.getElementById("check_BROWNIAN_MOTION_GEO");
    const check_ORNSTEIN_UHLENBECK = document.getElementById("check_ORNSTEIN_UHLENBECK");

    const myCanvas = document.getElementById("myCanvas");
    const ctx = myCanvas.getContext("2d");

    let mu, sigma, lambda, n, theta;
    let numberOfSamplePaths;
    let allPaths;
    let myRandomJump;
    let myVariate;
    let representAsScalingLimit;
    let myProcessValueType;
    let myProcessValueDescription;
    let myVariate_MinView;
    let myVariate_MaxView;
    let myProcessValue_Range;
    let intervalSize;
    let NumberOfClasses;
    let x_Origin;
    let y_Origin;
    let timeForHistogram_t;
    let timeForHistogram_n;
    let avgAtLastTime;              //media della variata al tempo n
    let ssAtLastTime;               //somma quadrati della variata al tempo n
    let intervals_t;                //intervalli per distribuzione tempo intermedio
    let intervals_n;                //intervalli per distribuzione tempo finale
    let MyTimer;
    let representAsAnimation;
    let currentPathNumber;
    let mul = false;

    const rectChart = new Rettangolo(20, 30, myCanvas.width - 200, myCanvas.height - 30 - 40);

    buttonRecompute.onclick = mainTask;

    mainTask();

    function acquisizioneScelteUtente() {

        mu = Number(inputMu.value);
        sigma = Number(inputSigma.value);
        lambda = Number(inputLambda.value);
        theta = Number(inputTheta.value);
        n = Math.round(Number(inputTimes.value));  //forzo conversione intero per assicurare l'uguaglianza con l'indice t del loop
        numberOfSamplePaths = Number(inputPaths.value);
        NumberOfClasses = Math.max(100, numberOfSamplePaths / 60);

        timeForHistogram_t = Math.round(n / 2);
        timeForHistogram_n = n;

        const sigmaMultipleForRange = 4;

        const dt = 1 / n;
        const sigma_sqrt_dt = sigma * Math.sqrt(dt);          //varianza proporzionale al tempo
        const sqrt_dt = Math.sqrt(dt);              //caso di sigma=1

        if (check_BROWNIAN_MOTION_STANDARD.checked) {
            myProcessValueDescription = 'Standard BM ≈ Σ N(0, dt), where dt=1/n, mean=0, var=1 at last time n, taken as 1';
            myProcessValueType = MyChosenVariate.BROWNIAN_MOTION_STANDARD;
            representAsScalingLimit = true;
            myVariate_MinView = -sigmaMultipleForRange;
            myVariate_MaxView = sigmaMultipleForRange;
            myRandomJump = () => MyRndUtilities.gaussian(0, sqrt_dt);
            myVariate = (sumOfJumps) => sumOfJumps;
            mul = false;

        } else if (check_BROWNIAN_MOTION_GEN.checked) {
            myProcessValueDescription = "general (arithmetic) Brownian motion ≈ Σ N(μ dt, σ² dt), where dt=1/n, mean=μ, var=σ² at last time n, taken as 1";
            myProcessValueType = MyChosenVariate.BROWNIAN_MOTION_GENERAL;
            representAsScalingLimit = true;
            myVariate_MinView = Math.min(0, mu - sigmaMultipleForRange * sigma);
            myVariate_MaxView = Math.max(0, mu + sigmaMultipleForRange * sigma);
            myRandomJump = () => MyRndUtilities.gaussian(mu * dt, sigma_sqrt_dt);
            myVariate = (sumOfJumps) => sumOfJumps;
            mul = false;

        } else if(check_BROWNIAN_MOTION_GEO.checked){
            myProcessValueDescription = "Geometric Brownian motion ≈ S_t = S_0 exp((μ - σ²/2)dt + σ W_t), where W_t is a standard BM))";
            myProcessValueType = MyChosenVariate.BROWNIAN_MOTION_GEO;
            representAsScalingLimit = true;
            myVariate_MinView = 0;
            myVariate_MaxView = Math.exp((mu + 3 * sigma) * n * dt);
            myRandomJump = () => Math.exp(MyRndUtilities.gaussian((mu - sigma * sigma /2) * dt, sigma_sqrt_dt));
            myVariate = (productOfJumps) => productOfJumps;
            mul = true;
        
        } else if(check_ORNSTEIN_UHLENBECK){
            myProcessValueDescription = "Ornstein-Uhlenbeck process ≈ X_t = θ(μ - X_t)dt + σ dW_t, where W_t is a standard BM))";
            myProcessValueType = MyChosenVariate.ORNSTEIN_UHLENBECK;
            representAsScalingLimit = true;
            myVariate_MinView = mu - sigmaMultipleForRange * sigma;
            myVariate_MaxView = mu + sigmaMultipleForRange * sigma;
            myRandomJump = (currentX) => MyRndUtilities.gaussian(theta * (mu - currentX) * dt, sigma_sqrt_dt);
            myVariate = (sumOfJumps) => sumOfJumps;
            mul = false;
        }

        myProcessValue_Range = myVariate_MaxView - myVariate_MinView;
        intervalSize = myProcessValue_Range / NumberOfClasses;

        [x_Origin, y_Origin] = My2dUtilities.transformXYToViewport([0, 0], 0, n, myVariate_MinView, myProcessValue_Range, rectChart);

    }

    function mainTask() {

        clearInterval(MyTimer);
        acquisizioneScelteUtente();     //acquisizione nuove scelte
        intervals_t = [];               //intervalli per distribuzione tempo intermedio
        intervals_n = [];               //intervalli per distribuzione tempo finale
        currentPathNumber = 0;
        avgAtLastTime = 0;              //media della variata al tempo n
        ssAtLastTime = 0;               //somma quadrati della variata al tempo n
        ctx.clearRect(0, 0, myCanvas.width, myCanvas.height);
        allPaths = [];



            //generazione sample paths
            for (let s = 1; s <= numberOfSamplePaths; s++) {
                const newPath = createSinglePath(s);
                allPaths.push(newPath);
                ctx.lineWidth = 1;
                ctx.strokeStyle = MyChartUtilities.randomColorCSS();      //MyChartUtilities.randomColor();
                ctx.stroke(newPath);
            }

            sovrapponiIstogrammi();
            creaTaccheELegenda();
        

    }

    function redrawAll(AllgrayOneRed) {

        ctx.clearRect(0, 0, myCanvas.width, myCanvas.height);

        for (const p of allPaths) {
            ctx.lineWidth = 1;
            if (AllgrayOneRed) {
                ctx.strokeStyle = MyChartUtilities.randomRgbaString(0.2);
            } else {
                ctx.strokeStyle = MyChartUtilities.randomColorCSS();
            }
            ctx.stroke(p);
        }
        if (AllgrayOneRed) {
            ctx.lineWidth = 2;
            ctx.strokeStyle = "red";
            ctx.stroke(allPaths[allPaths.length - 1]);
        }

        sovrapponiIstogrammi();
        creaTaccheELegenda();

    }

    function performAnimationForEachpath() {

        const newPath = createSinglePath(allPaths.length + 1);
        allPaths.push(newPath);
        redrawAll(true);


        if (allPaths.length >= numberOfSamplePaths) {
            clearInterval(MyTimer);
            redrawAll(false);
        }
    }

    function sovrapponiIstogrammi() {

        //rettangolo contenitore istogramma
        const rettangoloIstogramma_t = new Rettangolo(My2dUtilities.transformX(timeForHistogram_t, 0, n, rectChart.x, rectChart.width), rectChart.y, 150, rectChart.height);
        const rettangoloIstogramma_n = new Rettangolo(My2dUtilities.transformX(timeForHistogram_n, 0, n, rectChart.x, rectChart.width), rectChart.y, 150, rectChart.height);
        rettangoloIstogramma_t.disegnaRettangolo(ctx, "rgba(100,100,250,0.5)", 2, [1, 1]);
        rettangoloIstogramma_n.disegnaRettangolo(ctx, "rgba(250,100,150,0.5)", 2, [1, 1]);

        //istogrammi
        MyChartUtilities.verticalHistoFromIntervals(ctx, intervals_t, myVariate_MinView, myVariate_MaxView - myVariate_MinView, rettangoloIstogramma_t, "red", 1, "yellow");
        MyChartUtilities.verticalHistoFromIntervals(ctx, intervals_n, myVariate_MinView, myVariate_MaxView - myVariate_MinView, rettangoloIstogramma_n, "red", 1, "yellow");

    }

    function createSinglePath(s) {

        currentPathNumber = s;
        const myPath = new Path2D();

        let sumOfJumps = mul ? 1 : 0;
        let previousY_Variate = y_Origin;

        myPath.moveTo(x_Origin, y_Origin);   //visualmente facciamo partire la path dall'origine

        for (let t = 1; t <= n; t++) {

            sumOfJumps = mul ? sumOfJumps * myRandomJump(sumOfJumps) : sumOfJumps + myRandomJump(sumOfJumps);
            console.log(sumOfJumps);
            let myProcessValue = myVariate(sumOfJumps, t);

            //raccolta valori per istogramma
            if (t === timeForHistogram_t) {
                MyDistributionUtilities.allocateValueInIntervals(myProcessValue, intervals_t, intervalSize);
            } else if (t === timeForHistogram_n) {
                MyDistributionUtilities.allocateValueInIntervals(myProcessValue, intervals_n, intervalSize);
                [avgAtLastTime, ssAtLastTime] = MyDistributionUtilities.UpdateMeanAndSS(myProcessValue, s, [avgAtLastTime, ssAtLastTime]);
            }

            const ascissa_t = My2dUtilities.transformX(t / n, 0, 1, rectChart.x, rectChart.width);

            //const ascissa_t = My2dUtilities.transformX(t, 0, n, rectChart.x, rectChart.width);
            const ordinata = My2dUtilities.transformY(myProcessValue, myVariate_MinView, myProcessValue_Range, rectChart.y, rectChart.height);

            //scalino mantenendo quota precedente
            myPath.lineTo(ascissa_t, previousY_Variate);
            //salva quota per prossimo scalino
            previousY_Variate = ordinata;

            myPath.lineTo(ascissa_t, ordinata);
        }

        return myPath;

    }

    function creaTaccheELegenda() {

        //rettangolo simulazione
        rectChart.disegnaRettangolo(ctx, "darkblue", 2, []);

        //label riferimenti numerici range, media, sigma della variata
        ctx.font = "11px Verdana";
        ctx.fillStyle = "white";
        ctx.fillText(myVariate_MaxView.toFixed(1), rectChart.right() + 10, rectChart.y - 7);
        ctx.fillText(myVariate_MinView.toFixed(1), rectChart.right() + 10, rectChart.bottom() - 7);
        ctx.fillStyle = "lightblue";
        ctx.fillText("paths: " + currentPathNumber + "  avg = " + avgAtLastTime.toFixed(2) + "  var = " + (ssAtLastTime / numberOfSamplePaths).toFixed(2), rectChart.x + 350, rectChart.bottom() + 30);
        ctx.fillStyle = "white";
        ctx.fillText(myProcessValueDescription, rectChart.x + 100, rectChart.y + 15);

        //tacche tempi/trials e tempi

        ctx.beginPath();

        if (representAsScalingLimit) {      //scaling limit: 0 -- 1
            ctx.fillStyle = "orange";
            ctx.strokeStyle = "orange";
            for (let t = 0; t <= 1; t += 0.1) {
                let ascissa_t = My2dUtilities.transformX(t, 0, 1, rectChart.x, rectChart.width);
                ctx.moveTo(ascissa_t, rectChart.bottom() - 3);
                ctx.lineTo(ascissa_t, rectChart.bottom() + 3);
                ctx.fillText(t.toFixed(1).toString(), ascissa_t - 5, rectChart.bottom() + 15);
            }

        } else {

            ctx.fillStyle = "white";
            ctx.strokeStyle = "white";
            const step = 10 ** Math.round(Math.log10(n) - 1);
            for (let t = 0; t <= n; t += step) {
                let ascissa_t = My2dUtilities.transformX(t, 0, n, rectChart.x, rectChart.width);
                ctx.moveTo(ascissa_t, rectChart.bottom() - 3);
                ctx.lineTo(ascissa_t, rectChart.bottom() + 3);
                ctx.fillText(t.toFixed(1).toString(), ascissa_t - 5, rectChart.bottom() + 15);
            }
        }
        ctx.stroke();

    }

</script>

</body>
</html>
