<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework 3</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet">
    <link rel="stylesheet" href="./../style.css">
    <link rel="icon" href="../photo1697031896 - Copia.jpeg" type="image/x-icon">

    <style>

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        footer {
            background-color: rgb(130, 23, 41);
            color: #fff;
            padding: 10px;
        }

        footer div {
            display: inline-block;
            margin-right: 20px;
            margin-top: 5px;
        }

        select {
            background-color: rgb(130, 23, 41);
            color: #fff;
            border: none;
            margin-top: 5px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        th, td {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
        }

        th {
            background-color: #f2f2f2;
        }

        .code-box {
            background-color: #333;
            color: #fff;
            padding: 10px;
            margin: 10px 70px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 13px;
        }

        .canvas-container {
            display: inline-block;
            resize: both;
            overflow: auto;
            border: 1px solid #ccc;
            margin: 10px;
            position: relative;
            background-color: whitesmoke;
            width: var(--canvas-scale, 60%);
            height: var(--canvas-scale, 60%);
            display: block;
        }

        .canvas-row {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .canvas-center {
            display: flex;
            justify-content: center;
        }

        .canvas-container canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .mybutton{
            background-color: black;
        }


    </style>
    <link rel="stylesheet" href="./../style.css">
    <script src="excel-reader.js"></script>
</head>
<body>
    
    <!-- Contenuto principale della pagina -->
    <footer style="padding: 10px 0;">
        <div>
            <img src="./../photo1697031896.jpeg" style="width: 110px; height: 45px;">
            <a href="./../index.html">
                <button>Home</button>
            </a>
            <span style="line-height: 45px; margin-left: 30px; margin-right: 30px;">Statistics 2023/2024</span>
            <span style="line-height: 45px; margin-right: 100px;">Chiara Iannicelli 1957045</span>
        </div>
        </footer>
    
    
    
        <div style="display: flex; align-items: center; justify-content: space-between; margin-right: 20px;">
            <h1>Homework 3.1</h1>
            <a href="homework_3_2.html">
                <button class="centered-button black-button">Homework 3.2</button>
            </a>
        </div>
        <br>

        <p style="font-size: 20px;">
        <b>Part a </b><br>
M systems are subject to a series of N attacks. On the x-axis, we indicate the attacks and on the Y-axis we
simulate the accumulation of a "security score" (-1, 1), where the score is -1 if the system is penetrated
and 1 if the system was successfully "shielded" or protected. Simulate the score "trajectories" for all systems,
assuming, for simplicity, a constant penetration probability p at each attack.
</p>
<p style="font-size: 20px;">
<b>Part b </b><br>
Same as before, but simulate the cumulated frequency, say f, of penetration. Do the same with the relative
frequency f/number of attacks and the "normalized" ratio: f/ âˆšnumber of attacks.
</p>
<p style="font-size: 20px;">
For any of the above 4 charts (which will be actually an instance of a unique "object", from a coder's point of view), plot
a vertical histogram at some point x (day or attack number, user parameter) and at the last abscissa
value and make your personal considerations on the shape of the distributions.
Make sure that each animation is enclosed into a "frame" (a rectangle) resizable by the user, by using the mouse
(you can make a separate, reusable, "ResizableRectangle" object for that).
</p>

<br>

        <div class="centered">
            <p style="font-size: 20px;">
                <label for="M"> <b>Number of systems (M):</b></label>
                <input type="number" id="M" value="5" min="1">
            </p>
                <p style="font-size: 20px;">
                <label for="N"><b>Number of attacks (N):</b></label>
                <input type="number" id="N" value="10" min="1"> 
            </p>
            <p style="font-size: 20px;">
                <label for="p"b> <b>Penetration probability (p):</b> </label>
                <input type="number" id="p" value="0.5" step="0.01" min="0" max="1">
            </p>
            <p style="font-size: 20px;">
                <label for="attackNumber"> <b>Attack number to analyze: </b></label>
                <input type="number" id="attackNumber" value="5" min="0" max="10">
            </p>
            <br><br>

            <p style="font-size: 20px;">
                Click on the button below to update all the charts
            </p>

                <button onclick="updateAllCharts()">Update Chart</button>
                <br><br>
                <p style="font-size: 20px;">
                    All the canvas are resizable, but you can choose to modify the aspect also using the buttons below.
                </p>
                <div class="centered">
                    <button class="mybutton" onclick="setCustomScale(0.1)">10%</button>
                    <button class="mybutton" onclick="setCustomScale(0.2)">20%</button>
                    <button class="mybutton" onclick="setCustomScale(0.3)">30%</button>
                    <button class="mybutton" onclick="setCustomScale(0.4)">40%</button>
                    <button class="mybutton" onclick="setCustomScale(0.5)">50%</button>
                    <button class="mybutton" onclick="setCustomScale(0.6)">60%</button>
                    <button class="mybutton" onclick="setCustomScale(0.7)">70%</button>
                    <button class="mybutton" onclick="setCustomScale(0.8)">80%</button>
                    <button class="mybutton" onclick="setCustomScale(0.9)">90%</button>
                    <button class="mybutton" onclick="setCustomScale(1.0)">100%</button>
                </div>
        </div>

        
    <script>
            function setCustomScale(customScale) {
                if (!isNaN(customScale) && customScale >= 0 && customScale <= 1) {
                    // Aggiorna la variabile CSS con il valore personalizzato
                    document.documentElement.style.setProperty('--canvas-scale', (customScale * 100) + '%');
                } else {
                    alert("Invalid custom scale. Please enter a number between 0 and 1.");
                }
            }

    </script>
       
        <br>
        
        <div class="centered">

            <h3>Security score</h3>
        </div>

        <div class="canvas-center">
            <div class="canvas-container">
                <div class="canvas-row">
                        <canvas id="securityChartOriginal" width="800" height="400"></canvas>
                    </div>
                </div>
            </div>

            <div class="centered">

                <h3>Cumulative frequency</h3>
            </div>
        <div class="canvas-center">
            <div class="canvas-container">
                <div class="canvas-row">
                        <canvas id="securityChart1b" width="800" height="400"></canvas>
                    </div>
                </div>
            </div>
            <div class="centered">

                <h3>Relative frequency</h3>
            </div>
        <div class="canvas-center">
            <div class="canvas-container">
                <div class="canvas-row">
                        <canvas id="securityChart1c" width="800" height="400" ></canvas>
                    </div>
                </div>
            </div>
            <div class="centered">

                <h3>Normalized frequency</h3>
            </div>
        <div class="canvas-center">
            <div class="canvas-container canvas">
                <div class="canvas-row">
                    <canvas id="securityChart1d" width="800" height="400" ></canvas>
                </div>
            </div>
        </div>
            
 
        <br>

        <p class="centered">
            Click on the button below to see source code.
        </p>
        <br><br>
        <button class="centered" onclick="showCode1();" >JavaScript</button> <br><br>

        <div class="code-box" id="code1" style="display: none;">

            <div class="language-javascript">
                <pre>
                    <code>
                        const canvasOriginal = document.getElementById('securityChartOriginal');
                        const canvas1b = document.getElementById('securityChart1b');
                        const canvas1c = document.getElementById('securityChart1c');
                        const canvas1d = document.getElementById('securityChart1d');

                        const ctxOriginal = canvasOriginal.getContext('2d');
                        const ctx1b = canvas1b.getContext('2d');
                        const ctx1c = canvas1c.getContext('2d');
                        const ctx1d = canvas1d.getContext('2d');

                        const scaleFactor = 0.9; // Adjust this value as needed, where 1 is full size and 0.5 is half size, etc.

                        let isDragging = false;
                        let startX, startY;

                        function startDrag(e) {
                            isDragging = true;
                            startX = e.clientX;
                            startY = e.clientY;
                        }

                        function drag(e) {
                            if (!isDragging) return;

                            const dx = e.clientX - startX;
                            const dy = e.clientY - startY;

                            const style = e.target.parentElement.style;
                            style.left = (parseInt(style.left || 0) + dx) + 'px'; // Fixed syntax error here
                            style.top = (parseInt(style.top || 0) + dy) + 'px'; // Fixed syntax error here

                            startX = e.clientX;
                            startY = e.clientY;
                        }


                        function stopDrag() {
                            isDragging = false;
                        }


                        const canvasContainers = document.querySelectorAll('.canvas-container');
                        canvasContainers.forEach(container => {
                            container.addEventListener('resize', function() {
                                scaleCanvasContent(container.querySelector('canvas'));
                            });
                            container.addEventListener('mousedown', startDrag);
                            container.addEventListener('mousemove', drag);
                            container.addEventListener('mouseup', stopDrag);
                            container.addEventListener('mouseleave', stopDrag); // Stops dragging if the mouse leaves the canvas
                        });

                        function scaleCanvasContent(canvas) {
                            const ctx = canvas.getContext('2d');
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCanvas.width = canvas.width;
                            tempCanvas.height = canvas.height;
                            tempCtx.drawImage(canvas, 0, 0);

                            canvas.width = canvas.parentElement.clientWidth;
                            canvas.height = canvas.parentElement.clientHeight;

                            ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, canvas.width, canvas.height);
                        }

                        function simulateScore(N, p, type = "original") {
                            let score = 0;
                            const scores = [];
                            for (let i = 0; i < N; i++) {
                                const probability = Math.random();
                                switch (type) {
                                    case "original":
                                        score += (probability < p) ? -1 : 1;
                                        break;
                                    case "1b":
                                        score += (probability < p) ? 0 : 1;
                                        break;
                                    case "1c":
                                        score += (probability < p) ? 0 : 1;
                                        score /= (i + 1);
                                        break;
                                    case "1d":
                                        score += (probability < p) ? 0 : 1;
                                        score /= Math.sqrt(i + 1);
                                        break;
                                }
                                scores.push(score);
                            }
                            return scores;
                        }

                        function countScoreIntervals(scores) {
                            const intervals = {};
                            for (let score of scores) {
                                const intervalBase = Math.floor(score / 2) * 2;
                                const intervalKey = `${intervalBase},${intervalBase + 2}`; // Use template literals
                                intervals[intervalKey] = (intervals[intervalKey] || 0) + 1;
                            }
                            return intervals;
                        }


                        function generateColors(count) {
                            const colors = [];
                            for (let i = 0; i < count; i++) {
                                colors.push(`hsl(${(i * 360) / count}, 100%, 50%)`); // Use backticks and quotes
                            }
                            return colors;
                        }


                        function drawChart(M, N, p, type, ctx, canvas) {
                            const attackNumber = parseInt(document.getElementById('attackNumber').value);

                            // Introduce scaling factor
                            const chartWidth = canvas.width * scaleFactor ;  
                            const chartHeight = canvas.height * scaleFactor;

                            // Adjust for scaling factor
                            const xOffset = 50;
                            const yOffset = chartHeight / 2;
                            const xScale = (chartWidth - xOffset) / N;
                            const yScale = yOffset / N;

                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const allScores = [];

                            const colors = generateColors(M);

                        // Axis and labels
                            ctx.strokeStyle = 'black';
                            ctx.beginPath();
                            ctx.moveTo(xOffset, 0);
                            ctx.lineTo(xOffset, canvas.height);
                            ctx.moveTo(xOffset, yOffset);
                            ctx.lineTo(xOffset + chartWidth, yOffset);
                            ctx.stroke();

                            // Drawing horizontal lines for every y-value
                            for (let i = -N; i <= N; i += 2) {
                                ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';  // Light gray color for lines
                                ctx.beginPath();
                                ctx.moveTo(xOffset, yOffset - i * yScale);
                                ctx.lineTo(xOffset + chartWidth, yOffset - i * yScale);
                                ctx.stroke();
                            }


                            // Label the Y axis
                            ctx.textAlign = "right";
                            ctx.fillStyle = "black";
                            for (let i = -N; i <= N; i += 2) {
                                if (i === N) {
                                    ctx.textBaseline = "top";  // Adjust for max value
                                } else if (i === -N) {
                                    ctx.textBaseline = "bottom";   // Adjust for min value
                                } else {
                                    ctx.textBaseline = "middle";
                                }
                                ctx.fillText(i, xOffset - 10, yOffset - i * yScale);
                            }

                            // Label the X axis
                            ctx.textAlign = "center";
                            ctx.textBaseline = "top";
                            ctx.fillStyle = "black";
                            for (let i = 1; i <= N; i++) {
                                let horizontalAdjustment = 0;
                                if (i === N) {
                                    horizontalAdjustment = -15; // Adjust left for max value; change the value as needed
                                }
                                ctx.fillText(i, xOffset + i * xScale + horizontalAdjustment, yOffset + 10);
                            }


                            // Simulate scores for all M systems and plot them
                            for (let system = 0; system < M; system++) {
                                const scores = simulateScore(N, p, type);
                                allScores.push(scores);
                                ctx.strokeStyle = colors[system];
                                ctx.beginPath();
                                ctx.moveTo(xOffset, yOffset);

                                for (let attack = 0; attack < N; attack++) {
                                    ctx.lineTo(xOffset + (attack + 1) * xScale, yOffset - scores[attack] * yScale);

                                    // Save the current context state
                                    ctx.save();
                                    // Drawing a circle for each point
                                    ctx.arc(xOffset + (attack + 1) * xScale, yOffset - scores[attack] * yScale, 1, 0, 2 * Math.PI);
                                    ctx.fillStyle = colors[system];
                                    ctx.fill();
                                    // Restore the context state to continue the line
                                    ctx.restore();

                                    // Move to the next point for line continuation
                                    ctx.moveTo(xOffset + (attack + 1) * xScale, yOffset - scores[attack] * yScale);
                                }

                                ctx.stroke();
                            }


                            // Count the final scores for the histogram
                            const endScores = allScores.map(scores => scores[N-1]);
                            const intervals = countScoreIntervals(endScores);

                            // Draw the histogram bars for each interval for the final scores
                            const maxBarWidth = canvas.width - (xOffset + N * xScale);
                            for (let intervalKey in intervals) {
                                const [start, end] = intervalKey.split(',').map(Number);
                                const midpoint = (start + end) / 2;
                                const count = intervals[intervalKey];

                                const barLength = (count / M) * maxBarWidth; 
                                const barStartY = yOffset - midpoint * yScale;
                                const barStartX = xOffset + N * xScale;  // Start at the last abscissa

                                ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
                                ctx.fillRect(barStartX, barStartY, barLength, yScale);
                            }


                            // Draw the histogram bars for the specific attack number
                            const attackScores = allScores.map(scores => scores[attackNumber - 1]);
                            const attackIntervals = countScoreIntervals(attackScores);

                            for (let intervalKey in attackIntervals) {
                                const [start, end] = intervalKey.split(',').map(Number);
                                const midpoint = (start + end) / 2;
                                const count = attackIntervals[intervalKey];

                                const barLength = ((count / M) * maxBarWidth);
                                const barStartY = yOffset - midpoint * yScale;
                                const barStartX = xOffset + attackNumber * xScale ;

                                ctx.fillStyle = 'rgba(100, 150, 255, 0.5)';
                                ctx.fillRect(barStartX, barStartY, barLength, yScale);
                            }
                        }

                        function updateChart() {
                            const M = parseInt(document.getElementById('M').value);
                            const N = parseInt(document.getElementById('N').value);
                            const p = parseFloat(document.getElementById('p').value);
                            drawChart(M, N, p);
                        }

                        function updateAllCharts() {
                            const M = parseInt(document.getElementById('M').value);
                            const N = parseInt(document.getElementById('N').value);
                            const p = parseFloat(document.getElementById('p').value);

                            drawChart(M, N, p, "original", ctxOriginal, canvasOriginal);
                            drawChart(M, N, p, "1b", ctx1b, canvas1b);
                            drawChart(M, N, p, "1c", ctx1c, canvas1c);
                            drawChart(M, N, p, "1d", ctx1d, canvas1d);
                        }

                        window.onload = function() {
                            updateAllCharts();
                        };
                    </code>
                </pre>

            </div>

        </div>

        <button class="centered" onclick="showCode2();" >C#</button> <br><br>

        <div class="code-box" id="code2" style="display: none;">

            <div class="language-csharp">
                <pre>
                    <code>
                        using System;
                        using System.Drawing;
                        using System.Windows.Forms;

                        class ChartDrawer : Form
                        {
                            private int M;
                            private int N;
                            private double p;

                            private TextBox MTextBox;
                            private TextBox NTextBox;
                            private TextBox pTextBox;

                            public ChartDrawer()
                            {
                                Text = "Homework 3";
                                Size = new Size(800, 600);
                                DoubleBuffered = true;

                                MTextBox = new TextBox();
                                MTextBox.Text = "5";
                                MTextBox.Location = new Point(10, 10);

                                NTextBox = new TextBox();
                                NTextBox.Text = "10";
                                NTextBox.Location = new Point(10, 40);

                                pTextBox = new TextBox();
                                pTextBox.Text = "0.5";
                                pTextBox.Location = new Point(10, 70);

                                Controls.Add(MTextBox);
                                Controls.Add(NTextBox);
                                Controls.Add(pTextBox);

                                Paint += new PaintEventHandler(OnPaint);
                            }

                            protected override void OnPaint(PaintEventArgs e)
                            {
                                base.OnPaint(e);

                                M = Convert.ToInt32(MTextBox.Text);
                                N = Convert.ToInt32(NTextBox.Text);
                                p = Convert.ToDouble(pTextBox.Text);

                                Graphics g = e.Graphics;
                                DrawChart(M, N, p, "original", g, ClientSize.Width, ClientSize.Height);
                            }

                            private void DrawChart(int M, int N, double p, string type, Graphics g, int width, int height)
                            {
                            private void DrawChart(int M, int N, double p, string type, Graphics g, int width, int height)
                        {
                            // Calcola i fattori di scala
                            float xScale = (width - 100) / N;
                            float yScale = height / (2 * N);

                            // Definisci i colori
                            Color[] colors = GenerateColors(M);

                            // Disegna l'asse delle ordinate
                            Pen axisPen = new Pen(Color.Black);
                            g.DrawLine(axisPen, 50, 0, 50, height);
                            g.DrawLine(axisPen, 50, height / 2, width, height / 2);

                            // Disegna le linee orizzontali
                            Pen gridPen = new Pen(Color.LightGray, 1);
                            for (int i = -N; i <= N; i += 2)
                            {
                                g.DrawLine(gridPen, 50, height / 2 - i * yScale, width, height / 2 - i * yScale);
                            }

                            // Etichette sull'asse delle ordinate
                            Font labelFont = new Font("Arial", 10);
                            Brush labelBrush = new SolidBrush(Color.Black);
                            StringFormat labelFormat = new StringFormat();
                            labelFormat.Alignment = StringAlignment.Far;
                            labelFormat.LineAlignment = StringAlignment.Center;
                            for (int i = -N; i <= N; i += 2)
                            {
                                if (i == N || i == -N)
                                    labelFormat.LineAlignment = StringAlignment.Near;
                                else
                                    labelFormat.LineAlignment = StringAlignment.Center;
                                g.DrawString(i.ToString(), labelFont, labelBrush, 40, height / 2 - i * yScale, labelFormat);
                            }

                            // Etichette sull'asse delle ascisse
                            labelFormat.Alignment = StringAlignment.Center;
                            labelFormat.LineAlignment = StringAlignment.Far;
                            for (int i = 1; i <= N; i++)
                            {
                                float horizontalAdjustment = 0;
                                if (i == N)
                                    horizontalAdjustment = -15;
                                g.DrawString(i.ToString(), labelFont, labelBrush, 50 + i * xScale + horizontalAdjustment, height / 2 + 10, labelFormat);
                            }

                            // Simula i punteggi e disegna il grafico
                            for (int system = 0; system < M; system++)
                            {
                                List<int> scores = SimulateScore(N, p, type);
                                Pen linePen = new Pen(colors[system], 2);
                                for (int attack = 0; attack < N - 1; attack++)
                                {
                                    float x1 = 50 + (attack * xScale);
                                    float y1 = height / 2 - scores[attack] * yScale;
                                    float x2 = 50 + ((attack + 1) * xScale);
                                    float y2 = height / 2 - scores[attack + 1] * yScale;

                                    g.DrawLine(linePen, x1, y1, x2, y2);
                                }
                            }
                        }

                        private List<int> SimulateScore(int N, double p, string type)
                        {
                            List<int> scores = new List<int>();
                            int score = 0;
                            for (int i = 0; i < N; i++)
                            {
                                double probability = new Random().NextDouble();
                                switch (type)
                                {
                                    case "original":
                                        score += (probability < p) ? -1 : 1;
                                        break;
                                    case "1b":
                                        score += (probability < p) ? 0 : 1;
                                        break;
                                    case "1c":
                                        score += (probability < p) ? 0 : 1;
                                        score /= (i + 1);
                                        break;
                                    case "1d":
                                        score += (probability < p) ? 0 : 1;
                                        score /= (int)Math.Sqrt(i + 1);
                                        break;
                                }
                                scores.Add(score);
                            }
                            return scores;
                        }

                        private Color[] GenerateColors(int count)
                        {
                            Color[] colors = new Color[count];
                            for (int i = 0; i < count; i++)
                            {
                                int hue = (i * 360) / count;
                                colors[i] = ColorFromAhsb(255, hue, 1.0f, 0.5f);
                            }
                            return colors;
                        }

                        // Helper function to create a color from alpha, hue, saturation, and brightness values
                        private Color ColorFromAhsb(int alpha, int hue, float saturation, float brightness)
                        {
                            float fMax, fMid, fMin;
                            int hi = (int)(hue / 60.0) % 6;
                            float f = hue / 60.0f - hi;
                            float f1 = 1 - f;

                            fMax = brightness;
                            fMin = brightness * (1.0f - saturation);
                            fMid = brightness * (1.0f - f * saturation);

                            int red, green, blue;

                            red = green = blue = (int)(brightness * 255);

                            switch (hi)
                            {
                                case 0:
                                    red = (int)(fMax * 255);
                                    green = (int)(fMid * 255);
                                    blue = (int)(fMin * 255);
                                    break;
                                case 1:
                                    red = (int)(fMid * 255);
                                    green = (int)(fMax * 255);
                                    blue = (int)(fMin * 255);
                                    break;
                                case 2:
                                    red = (int)(fMin * 255);
                                    green = (int)(fMax * 255);
                                    blue = (int)(fMax * 255);
                                    break;
                                case 3:
                                    red = (int)(fMin * 255);
                                    green = (int)(fMid * 255);
                                    blue = (int)(fMax * 255);
                                    break;
                                case 4:
                                    red = (int)(fMid * 255);
                                    green = (int)(fMin * 255);
                                    blue = (int)(fMax * 255);
                                    break;
                                case 5:
                                    red = (int)(fMax * 255);
                                    green = (int)(fMin * 255);
                                    blue = (int)(fMid * 255);
                                    break;
                            }

                            return Color.FromArgb(alpha, red, green, blue);
                        }


                            }

                            [STAThread]
                            public static void Main()
                            {
                                Application.Run(new ChartDrawer());
                            }
                        }

                    </code>
                </pre>
            </div>
        </div>

    <script src="script.js"></script>

    <script>
            function showCode1() {
                 var codeElement = document.getElementById('code1');
                 if (codeElement.style.display === 'none') {
                    codeElement.style.display = 'block'; // Mostra il codice
                } else {
                    codeElement.style.display = 'none'; // Nascondi il codice
                }
             }
            function showCode2() {
                 var codeElement = document.getElementById('code2');
                 if (codeElement.style.display === 'none') {
                    codeElement.style.display = 'block'; // Mostra il codice
                } else {
                    codeElement.style.display = 'none'; // Nascondi il codice
                }
             }
    </script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        

   

</body>
</html>