<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="../photo1697031896 - Copia.jpeg" type="image/x-icon">

    <title>Homework 5</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet">

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        footer {
            background-color: rgb(130, 23, 41);
            color: #fff;
            padding: 10px; /* Aggiungi spazio intorno ai contenuti del footer */
        }

        footer div {
            display: inline-block; /* Posiziona gli elementi div in linea */
            margin-right: 20px; /* Aggiungi spazio tra gli elementi a sinistra */
            margin-top: 5px;
        }

        select {
            background-color: rgb(130, 23, 41);
            color: #fff;
            border: none;
            margin-top: 5px;
        }

        .code-box {
            background-color: #333; /* Sfondo scuro per la box del codice */
            color: #fff;
            padding: 10px;
            margin: 10px 70px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 13px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        th, td {
            border: 1px solid #dddddd;
            text-align: left;
            padding: 8px;
        }

        th {
            background-color: #f2f2f2;
        }

        .canvas-container {
            display: inline-block;
            resize: both;
            overflow: auto;
            border: 1px solid #ccc;
            margin: 10px;
            position: relative;
            background-color: whitesmoke;
            width: var(--canvas-scale, 60%);
            height: var(--canvas-scale, 60%);
            display: block;
        }

        .canvas-row {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .canvas-center {
            display: flex;
            justify-content: center;
        }

        .canvas-container canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .mybutton{
            background-color: black;
        }
        /* Style to float the image to the left */
        img {
            float: left;
            margin-right: 20px; /* Adjust the margin as needed */
        }
    </style>
    <link rel="stylesheet" href="../style.css">
    <script src="excel-reader.js"></script>
</head>
<body>

    <footer style="padding: 10px 0;">
        <div>
            <img src="../photo1697031896.jpeg" style="width: 110px; height: 45px;">
    
            <a href="../index.html">
                <button>Home</button>
            </a>
        
            <span style="line-height: 45px; margin-left: 30px; margin-right: 30px;">Statistics 2023/2024</span>
            <span style="line-height: 45px; margin-right: 100px;">Chiara Iannicelli 1957045</span>
        </div>
        <div>
    </footer>
    
    <div style="display: flex; align-items: center; justify-content: space-between; margin-right: 20px;">
        <h1>Homework 5.1</h1>
        <a href="../homework_5/homework_5_2.html">
            <button class="centered-button black-button">Homework 5.2</button>
        </a>
    </div>

    <br>

    <p style="font-size: 20px;">
    <b>Exercise </b><br>
M servers are subject to attacks during a period of time T (for instance 1 year).
Subdivide the interval T in N subinterval of size T/N and in each of this suppose that
an attack can occur with probability λ = T/N.
Simulate the attacks to the M servers and represent each of them with a line which
makes jumps of 1 at each attack event.
</p>
<p style="font-size: 20px;">
Using the same objects ("movable/resizable rectangle", histogram, etc.) of the previous homework 3
draw vertically on the line chart the 2 histograms representing the distribution of the number
of attacks at the end of the period and one internal istant for comparison.
</p>
<p style="font-size: 20px;">
Study what happens asymptotically, for N large, and a number of systems M a sufficient to give shape to
a simulated distribution. Make some personal considerations about the shape and the average of the distributions that you see.
</p>

<br>

<div class="centered">
    <p style="font-size: 20px;">
        <label for="M"> <b>Number of systems (M):</b></label>
        <input type="number" id="M" value="20" min="1">
    </p>
    <p style="font-size: 20px;">
        <label for="N"><b>Number of subinterval (N):</b></label>
        <input type="number" id="N" value="15" min="1"> <br>
    </p>
    <p style="font-size: 15px;">
        There'll be one attack in every subinterval with probability lambda
    </p>
    <p style="font-size: 20px;">
        <label for="T"><b>Period of time (T):</b></label>
        <input type="number" id="T" value="1" min="1"> 
    </p>
    <p style="font-size: 15px;">
        Let's assume 1 T is 1 year
    </p>
    <p style="font-size: 20px;">
        <label for="lambda"><b>Value of lambda (λ):</b></label>
        <input type="number" id="lambda" value="5" min="1">
    </p>
    <p style="font-size: 20px;">
        <label for="attackNumber"> <b>Attack number to analyze: </b></label>
        <input type="number" id="attackNumber" value="5" min="0" max="10">
    </p>
    <br><br>

    <p style="font-size: 20px;">
        Click on the button below tu update all the charts
    </p>

        <button onclick="updateAllCharts()">Update Chart</button>
        <br><br>
        <p style="font-size: 20px;">
            All the canvas are resizable, but you can choose to modify the aspect also using the buttons below.
        </p>
        <div class="centered">
            <button class="mybutton" onclick="setCustomScale(0.1)">10%</button>
            <button class="mybutton" onclick="setCustomScale(0.2)">20%</button>
            <button class="mybutton" onclick="setCustomScale(0.3)">30%</button>
            <button class="mybutton" onclick="setCustomScale(0.4)">40%</button>
            <button class="mybutton" onclick="setCustomScale(0.5)">50%</button>
            <button class="mybutton" onclick="setCustomScale(0.6)">60%</button>
            <button class="mybutton" onclick="setCustomScale(0.7)">70%</button>
            <button class="mybutton" onclick="setCustomScale(0.8)">80%</button>
            <button class="mybutton" onclick="setCustomScale(0.9)">90%</button>
            <button class="mybutton" onclick="setCustomScale(1.0)">100%</button>
        </div>
</div>


<br><br>

<div class="centered" style="display: none;">

    <h3>Security score</h3>
</div>

<div class="canvas-center" style="display: none;">
    <div class="canvas-container">
        <div class="canvas-row">
                <canvas id="securityChartOriginal" width="800" height="400"></canvas>
            </div>
        </div>
    </div>

    <div class="centered">

        <h3>Cumulative frequency</h3>
    </div>
<div class="canvas-center">
    <div class="canvas-container">
        <div class="canvas-row">
                <canvas id="securityChart1b" width="800" height="400"></canvas>
            </div>
        </div>
    </div>
    <div class="centered" style="display: none;" >

        <h3>Relative frequency</h3>
    </div>
<div class="canvas-center" style="display: none;" >
    <div class="canvas-container">
        <div class="canvas-row">
                <canvas id="securityChart1c" width="800" height="400" ></canvas>
            </div>
        </div>
    </div>
    <div class="centered" style="display: none;">

        <h3>Normalized frequency</h3>
    </div>
<div class="canvas-center" style="display: none;">
    <div class="canvas-container canvas">
        <div class="canvas-row">
            <canvas id="securityChart1d" width="800" height="400" ></canvas>
        </div>
    </div>
</div>
    
<br><br>
<p  style="font-size: 20px;">
    As <b>N</b> becomes large, the distribution of the number of attacks should approach a <b>Poisson distribution</b>, because the number of attacks is a sum of a large number of independent Bernoulli random variables (each representing whether an attack occurs in a given interval), which is the condition under which the Poisson distribution is a good approximation.
</p>
<p  style="font-size: 20px;">
In the simulation, an “attack” is modeled as a Bernoulli trial — an experiment with two possible outcomes: “success” (an attack occurs) and “failure” (no attack). Each attack is assumed to occur independently with probability <b>lambda</b> in each of <b>T * N intervals</b>. <br><br>

The expected value (or average) of a Bernoulli trial is simply the probability of success, which in this case is lambda. So the expected number of attacks in a single interval is <b>lambda</b>. <br><br>

However, we’re not just looking at a single interval. We’re looking at T * N intervals. So to find the expected number of attacks over all intervals, we <b>multiply the expected number of attacks in a single interval by the total number of intervals</b>. <br> This gives us lambda * T * N. <br><br>

But remember that lambda was defined as <b>T / N</b>. So if we substitute T / N for lambda in the equation, we get (T / N) * T * N, which simplifies to <b>T</b>.

So the average number of attacks over the entire time period T is expected to be T, according to this model. <br><br>


So, the average of the distribution should be approximately equal to <b>lambda * T * N = T^2 / N * N = T</b>, because each attack occurs with probability lambda_ in each of T * N intervals. <br><br>

The shape of the distribution should be unimodal and skewed to the right, typical of a Poisson distribution with a relatively small mean. As the mean increases, the distribution becomes more symmetric and bell-shaped. The variance of the distribution should also be approximately equal to the mean, another characteristic of the Poisson distribution. <br><br>
</p>

<br>

<p class="centered">
    Click on the button below to see source code.
</p>
<br><br>

<button class="centered" onclick="showCode1();" >JavaScript</button> <br><br>

        <div class="code-box" id="code1" style="display: none;">

            <div class="language-javascript">
                <pre>
                    <code>
                        const canvasOriginal = document.getElementById('securityChartOriginal');
                        const canvas1b = document.getElementById('securityChart1b');
                        const canvas1c = document.getElementById('securityChart1c');
                        const canvas1d = document.getElementById('securityChart1d');
                        
                        const ctxOriginal = canvasOriginal.getContext('2d');
                        const ctx1b = canvas1b.getContext('2d');
                        const ctx1c = canvas1c.getContext('2d');
                        const ctx1d = canvas1d.getContext('2d');
                        
                        const scaleFactor = 0.9; // Adjust this value as needed, where 1 is full size and 0.5 is half size, etc.
                        
                        let isDragging = false;
                        let startX, startY;
                        
                        function startDrag(e) {
                            isDragging = true;
                            startX = e.clientX;
                            startY = e.clientY;
                        }
                        
                        function drag(e) {
                            if (!isDragging) return;
                        
                            const dx = e.clientX - startX;
                            const dy = e.clientY - startY;
                        
                            const style = e.target.parentElement.style;
                            style.left = (parseInt(style.left || 0) + dx) + 'px'; // Fixed syntax error here
                            style.top = (parseInt(style.top || 0) + dy) + 'px'; // Fixed syntax error here
                        
                            startX = e.clientX;
                            startY = e.clientY;
                        }
                        
                        
                        function stopDrag() {
                            isDragging = false;
                        }
                        
                        
                        const canvasContainers = document.querySelectorAll('.canvas-container');
                        canvasContainers.forEach(container => {
                            container.addEventListener('resize', function() {
                                scaleCanvasContent(container.querySelector('canvas'));
                            });
                            container.addEventListener('mousedown', startDrag);
                            container.addEventListener('mousemove', drag);
                            container.addEventListener('mouseup', stopDrag);
                            container.addEventListener('mouseleave', stopDrag); // Stops dragging if the mouse leaves the canvas
                        });
                        
                        function scaleCanvasContent(canvas) {
                            const ctx = canvas.getContext('2d');
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCanvas.width = canvas.width;
                            tempCanvas.height = canvas.height;
                            tempCtx.drawImage(canvas, 0, 0);
                        
                            canvas.width = canvas.parentElement.clientWidth;
                            canvas.height = canvas.parentElement.clientHeight;
                        
                            ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 0, 0, canvas.width, canvas.height);
                        }
                        
                        function simulateScore(N, p, type = "original") {
                            let score = 0;
                            const scores = [];
                            for (let i = 0; i < N; i++) {
                                const probability = Math.random();
                                switch (type) {
                                    case "original":
                                        score += (probability < p) ? -1 : 1;
                                        break;
                                    case "1b":
                                        score += (probability < p) ? 0 : 1;
                                        break;
                                    case "1c":
                                        score += (probability < p) ? 0 : 1;
                                        score /= (i + 1);
                                        break;
                                    case "1d":
                                        score += (probability < p) ? 0 : 1;
                                        score /= Math.sqrt(i + 1);
                                        break;
                                }
                                scores.push(score);
                            }
                            return scores;
                        }
                        
                        function countScoreIntervals(scores) {
                            const intervals = {};
                            for (let score of scores) {
                                const intervalBase = Math.floor(score / 2) * 2;
                                const intervalKey = `${intervalBase},${intervalBase + 2}`; // Use template literals
                                intervals[intervalKey] = (intervals[intervalKey] || 0) + 1;
                            }
                            return intervals;
                        }
                        
                        
                        function generateColors(count) {
                            const colors = [];
                            for (let i = 0; i < count; i++) {
                                colors.push(`hsl(${(i * 360) / count}, 100%, 50%)`); // Use backticks and quotes
                            }
                            return colors;
                        }
                        
                        
                        function drawChart(M, N, p, type, ctx, canvas) {
                            const attackNumber = parseInt(document.getElementById('attackNumber').value);
                        
                            // Introduce scaling factor
                            const chartWidth = canvas.width * scaleFactor ;  
                            const chartHeight = canvas.height * scaleFactor;
                        
                            // Adjust for scaling factor
                            const xOffset = 50;
                            const yOffset = chartHeight / 2;
                            const xScale = (chartWidth - xOffset) / N;
                            const yScale = yOffset / N;
                        
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const allScores = [];
                        
                            const colors = generateColors(M);
                        
                        // Axis and labels
                            ctx.strokeStyle = 'black';
                            ctx.beginPath();
                            ctx.moveTo(xOffset, 0);
                            ctx.lineTo(xOffset, canvas.height);
                            ctx.moveTo(xOffset, yOffset);
                            ctx.lineTo(xOffset + chartWidth, yOffset);
                            ctx.stroke();
                        
                            // Drawing horizontal lines for every y-value
                            for (let i = -N; i <= N; i += 2) {
                                ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';  // Light gray color for lines
                                ctx.beginPath();
                                ctx.moveTo(xOffset, yOffset - i * yScale);
                                ctx.lineTo(xOffset + chartWidth, yOffset - i * yScale);
                                ctx.stroke();
                            }
                        
                        
                            // Label the Y axis
                            ctx.textAlign = "right";
                            ctx.fillStyle = "black";
                            for (let i = -N; i <= N; i += 2) {
                                if (i === N) {
                                    ctx.textBaseline = "top";  // Adjust for max value
                                } else if (i === -N) {
                                    ctx.textBaseline = "bottom";   // Adjust for min value
                                } else {
                                    ctx.textBaseline = "middle";
                                }
                                ctx.fillText(i, xOffset - 10, yOffset - i * yScale);
                            }
                        
                            // Label the X axis
                            ctx.textAlign = "center";
                            ctx.textBaseline = "top";
                            ctx.fillStyle = "black";
                            for (let i = 1; i <= N; i++) {
                                let horizontalAdjustment = 0;
                                if (i === N) {
                                    horizontalAdjustment = -15; // Adjust left for max value; change the value as needed
                                }
                                ctx.fillText(i, xOffset + i * xScale + horizontalAdjustment, yOffset + 10);
                            }
                        
                        
                            // Simulate scores for all M systems and plot them
                            for (let system = 0; system < M; system++) {
                                const scores = simulateScore(N, p, type);
                                allScores.push(scores);
                                ctx.strokeStyle = colors[system];
                                ctx.beginPath();
                                ctx.moveTo(xOffset, yOffset);
                        
                                for (let attack = 0; attack < N; attack++) {
                                    ctx.lineTo(xOffset + (attack + 1) * xScale, yOffset - scores[attack] * yScale);
                        
                                    // Save the current context state
                                    ctx.save();
                                    // Drawing a circle for each point
                                    ctx.arc(xOffset + (attack + 1) * xScale, yOffset - scores[attack] * yScale, 1, 0, 2 * Math.PI);
                                    ctx.fillStyle = colors[system];
                                    ctx.fill();
                                    // Restore the context state to continue the line
                                    ctx.restore();
                        
                                    // Move to the next point for line continuation
                                    ctx.moveTo(xOffset + (attack + 1) * xScale, yOffset - scores[attack] * yScale);
                                }
                        
                                ctx.stroke();
                            }
                        
                        
                            // Count the final scores for the histogram
                            const endScores = allScores.map(scores => scores[N-1]);
                            const intervals = countScoreIntervals(endScores);
                        
                            // Draw the histogram bars for each interval for the final scores
                            const maxBarWidth = canvas.width - (xOffset + N * xScale);
                            for (let intervalKey in intervals) {
                                const [start, end] = intervalKey.split(',').map(Number);
                                const midpoint = (start + end) / 2;
                                const count = intervals[intervalKey];
                        
                                const barLength = (count / M) * maxBarWidth; 
                                const barStartY = yOffset - midpoint * yScale;
                                const barStartX = xOffset + N * xScale;  // Start at the last abscissa
                        
                                ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
                                ctx.fillRect(barStartX, barStartY, barLength, yScale);
                            }
                        
                        
                            // Draw the histogram bars for the specific attack number
                            const attackScores = allScores.map(scores => scores[attackNumber - 1]);
                            const attackIntervals = countScoreIntervals(attackScores);
                        
                            for (let intervalKey in attackIntervals) {
                                const [start, end] = intervalKey.split(',').map(Number);
                                const midpoint = (start + end) / 2;
                                const count = attackIntervals[intervalKey];
                        
                                const barLength = ((count / M) * maxBarWidth);
                                const barStartY = yOffset - midpoint * yScale;
                                const barStartX = xOffset + attackNumber * xScale ;
                        
                                ctx.fillStyle = 'rgba(100, 150, 255, 0.5)';
                                ctx.fillRect(barStartX, barStartY, barLength, yScale);
                            }
                        }
                        
                        function updateChart() {
                            const M = parseInt(document.getElementById('M').value);
                            const N = parseInt(document.getElementById('N').value);
                            const T = parseInt(document.getElementById('T').value);
                            const lambda = parseInt(document.getElementById('lambda').value);
                            const p = lambda * (T / N);
                            drawChart(M, N, p);
                        }
                        
                        function updateAllCharts() {
                            const M = parseInt(document.getElementById('M').value);
                            const N = parseInt(document.getElementById('N').value);
                            const T = parseInt(document.getElementById('T').value);
                            const lambda = parseInt(document.getElementById('lambda').value);
                            const p = lambda * (T / N);
                        
                            drawChart(M, N, p, "original", ctxOriginal, canvasOriginal);
                            drawChart(M, N, p, "1b", ctx1b, canvas1b);
                            drawChart(M, N, p, "1c", ctx1c, canvas1c);
                            drawChart(M, N, p, "1d", ctx1d, canvas1d);
                        }
                        
                        window.onload = function() {
                            updateAllCharts();
                        };                                        
                    </code>
                </pre>

            </div>

        </div>

        <button class="centered" onclick="showCode2();" >C#</button> <br><br>

        <div class="code-box" id="code2" style="display: none;">

            <div class="language-csharp">
                <pre>
                    <code>
                        using System;
                        using System.Drawing;
                        using System.Windows.Forms;

                        class ChartDrawer : Form
                        {
                            private int M;
                            private int N;
                            private double p;

                            private TextBox MTextBox;
                            private TextBox NTextBox;
                            private TextBox pTextBox;

                            public ChartDrawer()
                            {
                                Text = "Homework 3";
                                Size = new Size(800, 600);
                                DoubleBuffered = true;

                                MTextBox = new TextBox();
                                MTextBox.Text = "5";
                                MTextBox.Location = new Point(10, 10);

                                NTextBox = new TextBox();
                                NTextBox.Text = "10";
                                NTextBox.Location = new Point(10, 40);

                                pTextBox = new TextBox();
                                pTextBox.Text = "0.5";
                                pTextBox.Location = new Point(10, 70);

                                Controls.Add(MTextBox);
                                Controls.Add(NTextBox);
                                Controls.Add(pTextBox);

                                Paint += new PaintEventHandler(OnPaint);
                            }

                            protected override void OnPaint(PaintEventArgs e)
                            {
                                base.OnPaint(e);

                                M = Convert.ToInt32(MTextBox.Text);
                                N = Convert.ToInt32(NTextBox.Text);
                                p = Convert.ToDouble(pTextBox.Text);

                                Graphics g = e.Graphics;
                                DrawChart(M, N, p, "original", g, ClientSize.Width, ClientSize.Height);
                            }

                            private void DrawChart(int M, int N, double p, string type, Graphics g, int width, int height)
                            {
                            private void DrawChart(int M, int N, double p, string type, Graphics g, int width, int height)
                        {
                            // Calcola i fattori di scala
                            float xScale = (width - 100) / N;
                            float yScale = height / (2 * N);

                            // Definisci i colori
                            Color[] colors = GenerateColors(M);

                            // Disegna l'asse delle ordinate
                            Pen axisPen = new Pen(Color.Black);
                            g.DrawLine(axisPen, 50, 0, 50, height);
                            g.DrawLine(axisPen, 50, height / 2, width, height / 2);

                            // Disegna le linee orizzontali
                            Pen gridPen = new Pen(Color.LightGray, 1);
                            for (int i = -N; i <= N; i += 2)
                            {
                                g.DrawLine(gridPen, 50, height / 2 - i * yScale, width, height / 2 - i * yScale);
                            }

                            // Etichette sull'asse delle ordinate
                            Font labelFont = new Font("Arial", 10);
                            Brush labelBrush = new SolidBrush(Color.Black);
                            StringFormat labelFormat = new StringFormat();
                            labelFormat.Alignment = StringAlignment.Far;
                            labelFormat.LineAlignment = StringAlignment.Center;
                            for (int i = -N; i <= N; i += 2)
                            {
                                if (i == N || i == -N)
                                    labelFormat.LineAlignment = StringAlignment.Near;
                                else
                                    labelFormat.LineAlignment = StringAlignment.Center;
                                g.DrawString(i.ToString(), labelFont, labelBrush, 40, height / 2 - i * yScale, labelFormat);
                            }

                            // Etichette sull'asse delle ascisse
                            labelFormat.Alignment = StringAlignment.Center;
                            labelFormat.LineAlignment = StringAlignment.Far;
                            for (int i = 1; i <= N; i++)
                            {
                                float horizontalAdjustment = 0;
                                if (i == N)
                                    horizontalAdjustment = -15;
                                g.DrawString(i.ToString(), labelFont, labelBrush, 50 + i * xScale + horizontalAdjustment, height / 2 + 10, labelFormat);
                            }

                            // Simula i punteggi e disegna il grafico
                            for (int system = 0; system < M; system++)
                            {
                                List<int> scores = SimulateScore(N, p, type);
                                Pen linePen = new Pen(colors[system], 2);
                                for (int attack = 0; attack < N - 1; attack++)
                                {
                                    float x1 = 50 + (attack * xScale);
                                    float y1 = height / 2 - scores[attack] * yScale;
                                    float x2 = 50 + ((attack + 1) * xScale);
                                    float y2 = height / 2 - scores[attack + 1] * yScale;

                                    g.DrawLine(linePen, x1, y1, x2, y2);
                                }
                            }
                        }

                        private List<int> SimulateScore(int N, double p, string type)
                        {
                            List<int> scores = new List<int>();
                            int score = 0;
                            for (int i = 0; i < N; i++)
                            {
                                double probability = new Random().NextDouble();
                                switch (type)
                                {
                                    case "original":
                                        score += (probability < p) ? -1 : 1;
                                        break;
                                    case "1b":
                                        score += (probability < p) ? 0 : 1;
                                        break;
                                    case "1c":
                                        score += (probability < p) ? 0 : 1;
                                        score /= (i + 1);
                                        break;
                                    case "1d":
                                        score += (probability < p) ? 0 : 1;
                                        score /= (int)Math.Sqrt(i + 1);
                                        break;
                                }
                                scores.Add(score);
                            }
                            return scores;
                        }

                        private Color[] GenerateColors(int count)
                        {
                            Color[] colors = new Color[count];
                            for (int i = 0; i < count; i++)
                            {
                                int hue = (i * 360) / count;
                                colors[i] = ColorFromAhsb(255, hue, 1.0f, 0.5f);
                            }
                            return colors;
                        }

                        // Helper function to create a color from alpha, hue, saturation, and brightness values
                        private Color ColorFromAhsb(int alpha, int hue, float saturation, float brightness)
                        {
                            float fMax, fMid, fMin;
                            int hi = (int)(hue / 60.0) % 6;
                            float f = hue / 60.0f - hi;
                            float f1 = 1 - f;

                            fMax = brightness;
                            fMin = brightness * (1.0f - saturation);
                            fMid = brightness * (1.0f - f * saturation);

                            int red, green, blue;

                            red = green = blue = (int)(brightness * 255);

                            switch (hi)
                            {
                                case 0:
                                    red = (int)(fMax * 255);
                                    green = (int)(fMid * 255);
                                    blue = (int)(fMin * 255);
                                    break;
                                case 1:
                                    red = (int)(fMid * 255);
                                    green = (int)(fMax * 255);
                                    blue = (int)(fMin * 255);
                                    break;
                                case 2:
                                    red = (int)(fMin * 255);
                                    green = (int)(fMax * 255);
                                    blue = (int)(fMax * 255);
                                    break;
                                case 3:
                                    red = (int)(fMin * 255);
                                    green = (int)(fMid * 255);
                                    blue = (int)(fMax * 255);
                                    break;
                                case 4:
                                    red = (int)(fMid * 255);
                                    green = (int)(fMin * 255);
                                    blue = (int)(fMax * 255);
                                    break;
                                case 5:
                                    red = (int)(fMax * 255);
                                    green = (int)(fMin * 255);
                                    blue = (int)(fMid * 255);
                                    break;
                            }

                            return Color.FromArgb(alpha, red, green, blue);
                        }


                            }

                            [STAThread]
                            public static void Main()
                            {
                                Application.Run(new ChartDrawer());
                            }
                        }

                    </code>
                </pre>
            </div>
        </div>

    <script src="script.js"></script>

    <script>
            function showCode1() {
                 var codeElement = document.getElementById('code1');
                 if (codeElement.style.display === 'none') {
                    codeElement.style.display = 'block'; // Mostra il codice
                } else {
                    codeElement.style.display = 'none'; // Nascondi il codice
                }
             }
            function showCode2() {
                 var codeElement = document.getElementById('code2');
                 if (codeElement.style.display === 'none') {
                    codeElement.style.display = 'block'; // Mostra il codice
                } else {
                    codeElement.style.display = 'none'; // Nascondi il codice
                }
             }
    </script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        
<script>
    function setCustomScale(customScale) {
        if (!isNaN(customScale) && customScale >= 0 && customScale <= 1) {
            // Aggiorna la variabile CSS con il valore personalizzato
            document.documentElement.style.setProperty('--canvas-scale', (customScale * 100) + '%');
        } else {
            alert("Invalid custom scale. Please enter a number between 0 and 1.");
        }
    }

</script>

    <script src="script.js"></script>
</body>
</html>